//----------------------------------------------------------------------------------------------------------------------
/// @file MainWindow.cpp
/// @brief This is the MainWindow Class which is generated by the Ui file
//----------------------------------------------------------------------------------------------------------------------

#include "MainWindow.h"
#include "Renderer.h"
#include "ui_MainWindow.h"
#include "qfiledialog.h"

//----------------------------------------------------------------------------------------------------------------------
MainWindow::MainWindow(
                       QWidget *_parent
                      ):
                        QMainWindow(_parent),
                        m_ui(new Ui::MainWindow)
{
  // set the window size
  this->resize(QSize(1024,720));
  // create our GLWindow
  m_gl = new Renderer(this);
  // set the tite bar
  this->setWindowTitle(QString("Delaunay Tetrahedralization and its dual Voronoi"));
  // set the UI object
  m_ui->setupUi(this);
  m_ui->s_mainGridLayout->addWidget(m_gl,0,0,2,1);
  connect(m_ui->m_browse,SIGNAL(clicked()),this,SLOT(loadObjFile()));
  connect(m_ui->m_method, SIGNAL(activated(int)), this, SLOT(methodChanged(int)));
  connect(m_ui->m_points, SIGNAL(stateChanged(int)),m_gl,SLOT(isPointsActivated(int)));
  connect(m_ui->m_density, SIGNAL(valueChanged(int)),m_gl,SLOT(updateDensity(int)));
  connect(m_ui->m_surfacePoints, SIGNAL(stateChanged(int)),m_gl,SLOT(isSurfacePointsActivated(int)));
  connect(m_ui->m_intersectionPoints, SIGNAL(stateChanged(int)),m_gl,SLOT(isHitPointsActivated(int)));
  connect(m_ui->m_dCompute, SIGNAL(clicked()), m_gl, SLOT(isDelaunayComputeClicked()));
  connect(m_ui->m_vCompute, SIGNAL(clicked()), m_gl, SLOT(isVoronoiComputeClicked()));
  connect(m_ui->m_dClear, SIGNAL(clicked()), m_gl, SLOT(clearDelaunay()));
  connect(m_ui->m_vClear, SIGNAL(clicked()), m_gl, SLOT(clearVoronoi()));
  connect(m_ui->m_dWireframe, SIGNAL(stateChanged(int)), m_gl, SLOT(isDelaunayWireframeClicked(int)));
  connect(m_ui->m_pointOn, SIGNAL(activated(int)), this, SLOT(setPointType(int)));
}

//----------------------------------------------------------------------------------------------------------------------
MainWindow::~MainWindow()
{
    delete m_ui;
}

//----------------------------------------------------------------------------------------------------------------------
void MainWindow::keyPressEvent(
                               QKeyEvent *_event
                              )
{
  // this method is called every time the main window recives a key event.
  // we then switch on the key value and set the camera in the GLWindow
  switch (_event->key())
  {
  // escape key to quite
  case Qt::Key_Escape : QApplication::exit(EXIT_SUCCESS); break;
  // turn on wirframe rendering
  case Qt::Key_W : glPolygonMode(GL_FRONT_AND_BACK,GL_LINE); break;
  // turn off wire frame
  case Qt::Key_S : glPolygonMode(GL_FRONT_AND_BACK,GL_FILL); break;
  // show full screen
  case Qt::Key_F : showFullScreen(); break;
  // show windowed
  case Qt::Key_N : showNormal(); break;
  default : break;
  }
  // finally update the GLWindow and re-draw
  m_gl->updateGL();
}

//----------------------------------------------------------------------------------------------------------------------
void MainWindow::loadObjFile()
{
    // method allows user to browse for Obj file
    // and passes it to the Renderer class
    QString fileName = QFileDialog::getOpenFileName(this, tr("Open File"),"/path/to/file/",tr("obj Files (*.obj)"));
    m_ui->m_filePath->setText(fileName);
    m_gl->setObjFilename(fileName.toStdString());
}

//----------------------------------------------------------------------------------------------------------------------
void MainWindow::methodChanged( int _method )
{
    if(_method != 0)
    {
        m_ui->m_rayCastingGB->setEnabled(true);
        m_ui->m_surfacePoints->setEnabled(true);
        m_ui->m_intersectionPoints->setEnabled(true);
    }
    else
    {
        m_ui->m_rayCastingGB->setEnabled(false);
        m_ui->m_surfacePoints->setEnabled(false);
        m_ui->m_surfacePoints->setChecked(false);
        m_ui->m_intersectionPoints->setEnabled(false);
        m_ui->m_intersectionPoints->setChecked(false);

    }
    m_gl->updateMethod(_method);
}

//----------------------------------------------------------------------------------------------------------------------
void MainWindow::setPointType(int _type)
{
    if(_type != 0)
    {
        m_ui->m_method->setEnabled(false);
        m_ui->m_rayCastingGB->setEnabled(false);
        m_ui->m_surfacePoints->setEnabled(false);
        m_ui->m_intersectionPoints->setEnabled(false);
    }
    else
    {
        m_ui->m_method->setEnabled(true);
    }
    m_gl->pointLocation(_type);
}
//----------------------------------------------------------------------------------------------------------------------
